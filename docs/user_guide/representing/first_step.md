# Representing

At the heart of `DocArray` lies the concept of [`BaseDoc`][docarray.base_doc.doc.BaseDoc].

A [BaseDoc][docarray.base_doc.doc.BaseDoc] is very similar to a [Pydantic](https://docs.pydantic.dev/)
[`BaseModel`](https://docs.pydantic.dev/usage/models) - in fact it _is_ a specialized Pydantic `BaseModel`. It allows you to define custom `Document` schemas (or `Model` in
the Pydantic world) to represent your data.

## Basic `Doc` usage.

Before going in detail about what we can do with [BaseDoc][docarray.base_doc.doc.BaseDoc] and how to use it, let's
see what it looks like in practice.

The following Python code defines a `BannerDoc` class that can be used to represent the data of a website banner.

```python
from docarray import BaseDoc
from docarray.typing import ImageUrl


class BannerDoc(BaseDoc):
    image_url: ImageUrl
    title: str
    description: str
```

You can then instantiate a `BannerDoc` object and access its attributes.

```python
banner = BannerDoc(
    image_url="https://example.com/image.png",
    title="Hello World",
    description="This is a banner",
)

assert banner.image_url == "https://example.com/image.png"
assert banner.title == "Hello World"
assert banner.description == "This is a banner"
```




## `BaseDoc` is a Pydantic `BaseModel`

The class [BaseDoc][docarray.base_doc.doc.BaseDoc] inherits from pydantic [BaseModel](https://docs.pydantic.dev/usage/models). So you can use
all the features of `BaseModel` in your `Doc` class. 

This namely means that `BaseDoc`:

* Will perform data validation: `BaseDoc` will check that the data you pass to it is valid. If not, it will raise an
  error. Data being "valid"  is actually defined by the type used in the type hint itself, but we will come back to this concept later (TODO add typing section)

* Can be configured using a nested `Config` class, see pydantic [documentation](https://docs.pydantic.dev/usage/model_config/) for more details on what kind of config Pydantic offer.

* Can be used as a drop-in replacement for `BaseModel` in your code and is compatible with tools using Pydantic like [FastAPI]('https://fastapi.tiangolo.com/').


###  What is the difference with Pydantic `BaseModel`? (INCOMPLETE)

LINK TO THE VERSUS (not ready)

[BaseDoc][docarray.base_doc.doc.BaseDoc] is not only a [BaseModel](https://docs.pydantic.dev/usage/models), 

* it allows to be used with DocArray [Typed](docarray.typing) that are oriented toward MultiModal (image, audio, ...) data and for 
Machine Learning use case TODO link the type section. 

Another difference is that [BaseDoc][docarray.base_doc.doc.BaseDoc] has a generated by default `id` field that is used to uniquely identify a document.



## `BaseDoc` allows to represent multimodal and nested data.

Let's say you want to represent a Youtube video in your application, perhaps to build a search system for Youtube videos.
A Youtube video is not only composed of a video, but it also has a title, a description, a thumbnail (and more, but let's keep it simple).

All of these elements are from different `modalities` LINK TO MODALITIES SECTION (not ready): title and description are text, the thumbnail is an image, and the video in itself is, well, a video.

DocArray allows to represent all of this multimodal data in a single object. 

Let's first create an `BaseDoc` for each of the elements that compose the Youtube video.

First for the thumbnail which is an image
```python
from docarray import BaseDoc
from docarray.typing import ImageUrl, ImageBytes


class ImageDoc(BaseDoc):
    url: ImageUrl
    bytes: ImageBytes = (
        None  # bytes are not always loaded in memory, so we make it optional
    )
```

Then for the video which is a video
```python
from docarray import BaseDoc
from docarray.typing import VideoUrl, VideoBytes


class VideoDoc(BaseDoc):
    url: VideoUrl
    bytes: VideoBytes = (
        None  # bytes are not always loaded in memory, so we make it optional
    )
``` 


Then for the title and description which are text we will just use a `str` type.

All the elements that compose a Youtube video are ready:

```python
from docarray import BaseDoc


class YoutubeVideoDoc(BaseDoc):
    title: str
    description: str
    thumbnail: ImageDoc
    video: VideoDoc
```


You now have `YoutubeVideoDoc` which is a pythonic representation of a Youtube video. 

This representation can now be used to send (LINK) or to store (LINK) data. You can even use it directly to [train a machine learning](../../how_to/multimodal_training_and_serving.md) [Pytorch](https://pytorch.org/docs/stable/index.html) model on this representation. 


!!! note

    You see here that `ImageDoc` and `VideoDoc` are as well [BaseDoc][docarray.base_doc.doc.BaseDoc] that is later used inside another [BaseDoc][docarray.base_doc.doc.BaseDoc]`.
    This is what we call nested data representation. 

    [BaseDoc][docarray.base_doc.doc.BaseDoc] can be nested to represent any kind of data hierarchy.
  
  


See also:

* [BaseDoc][docarray.base_doc.doc.BaseDoc] API Reference
* DOCUMENT_ARARY REF
* DOCUMENT INDEX REF
* DOCUMENT STORE REF
* ...



See also